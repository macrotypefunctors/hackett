
we need to turn opaque-type-transformers into alias-transformers
instead of var-like-transformers so that #%type:app isn't recklessly
inserted. one justifaction for this is that opaque types actually
cannot be curried, since they may be "hiding" a type alias, not a data
type.

opaque types should expand into ((#%type:con #%apply-type) ...); a
u-type-app just like what we do in rep/sig.rkt. then we can resugar
them and the result will be the correct representation.

it may be nice if they shared a gensym property, so that Î»m and mod
can more easily call resugar without having to know of every type that
needs resugaring.

---

That's fine for opaque types, but data types might require something
else. They need to interact with pattern matching, so they do have to
be represented as (#%type:con data:M.D123). Is there a generic mechanism
for doing both opaque types as ((#%type:con #%apply-type) ...) and
data types as (#%type:con data:M.D123) ?


Both
    (opaque:M.T123 A)              ; the `opaque:M.T123` id is a declared-type-transformer struct
    =>
    ((con #%apply-type) ((con #%dot_\tau) M (con T)) A) + prop
    =>
    (#%apply-type (#%dot_\tau M T) A)
and
    (data:M.D456 A)                ; the `data:M.D456` id is a declared-type-transformer struct
    =>
    ((con data:M.D789) A) + prop   ; the `data:M.D789` id is a data-type-constructor struct
    =>
    (#%apply-type (#%dot_\tau M D) A)
?

The representation in signatures after expansion should be consistent (meaning: probably (#%apply-type (#%dot_\tau M D) A)) so that sealing works from data -> opaque, and so that "where"-ing works from opaque -> alias.

